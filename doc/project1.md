Design Document for Project 1: Threads
======================================


## GroupName
Timmy

## Group Members

* Tatia Tibunashvili <ttibu13@freeuni.edu.ge>
* Salome Kasradze <skasr13@freeuni.edu.ge>
* Niko Barateli <nbara14@freeuni.edu.ge>


			     ALARM CLOCK
			     ===========

---- სტრუქტურები ----

int64_t full_ticks; ეს ცვლადი ჩავამატე ყველა სრედში აღწერს სრედის სრულ ტიკებს.

static struct list sleep_list; ასევე დავამატე დალაგებული ლისტი მძინარე სრედებისთვის რომლის ინიციალიზაციაც ხდება taimer.c ინიტში.


---- ალგორითმი ----
ჯერ ვამოწმებ, თუ გადმოცემული ტიკების რაოდენობა ნაკლებია ან ტოლი ნულზე პირდაპირ ვარეთარნებ თუ არა
ინტერაპტებს გამორთვის შემდეგ ვააფდეითებ სრედის სრული ტიკების რაოდენობას.
სრედის ტიკები ხდება გადაცემულ არგუმენტს დამატებული ამ მომენტის სისტემური ტიკების რაოდენობა.
ეს სრედი ჩაინსერტდება მძინარე სრედების  ლისტში დასორტირებულად. რომელსაც გადავცემ შედარების ფუნქციას სრული ტიკების რაოდენობის მიხედვით.
ამის შემდეგ ინტერაპტებს კვლავ ვრთავთ.

ინტერაპტ ჰენდლერში გამოვრთავთ ინტერაფტს, გადავყვები მძინარე სრედების ლისტს ციკლით.
ყველა გასაღვიძებელ სრედს ვაღვიძებ შემდეგნაირად: ვამოწმებთ გასაღვიძებელია თუ არაა, თუ სრედი დაბლოკილი და მისი ტიკების რაოდენობა მეტია ან ტოლი ტაიმერ ტიკზე ვაუქმებთ ინტერაპტებს, ბლოკს ვხსნით სრედს, და ის ავტომატურად გადადის რედი ლისტში რომ სქედულერმა დაუთმოს რესურსი თუ ასე გადაწყვეტს. ლისტის გადაყოლის შემდეგ ვრთავთ ინტერაპტს. 


ჩამატება O(n)-ია, მაგრამ ამოღება O(1) რადგან დალაგებულად გვაქვს ტიკების მიხედვით.
თუ ბევრი სრედია გასაღვიძებელი ეს კარგი გადაწყვეტილებაა.

საჭირო ოპერაციები რომლებიც ლისტზე უნდა ჩატარდეს ხდება მაშინ,
როცა ინტერაპტები გამორთულია. ეს გვაძლევს გარანტიას რომ არ გაფუჭდება არაფერი პარალელიზმის დროს.

სხვა გადაწყვეტაზე არ მიფიქრია რადგან ეს საკმაოდ სწრაფად და კორეკტულად მუშაობს დალაგებული სიების გამო.

======TASK 2 - PRIORITY SCHEDULER ====

1.	 Data structures and functions

struct thread ის field:
	int * effective_priority;     პრიორიტეტი რომლის მიხედვითაც scheduling ხდება. ან სხვა ნაკადისგან მიიღო, ან თავისი priority ცვლადის მნიშვნელობაა.
	struct lock * wait_lock;      ლოქი, რომლის გამოც აქ ახლანდელი პრიორიტეტი( effective_priority)
	struct list_elem donor_elem;  ლისტ_ელემენტი, იმისთვის რომ ეს thread ობიექტი, რომელიმე სხვა ნაკადის დონორების ლისტში "ჩაეწეროს"
	struct list donations;        ლისტი, იმ ნაკადებისა, რომლებმაც ამ thread-ს პრიორიტეტი მისცეს. 
		 	
thread methods:
	bool get_priority(struct thread* recipient, struct thread* donor, struct lock * lock); thread იღებს პრიორიტეტს იმ ნაკადისგან, რომელსაც ის ლოქი უნდა, რომელიც მას აქვს.
	void remove_priority(struct thread* recipient, struct lock * lock);  lock_release ში, thread იცილებს იმ პრიორიტეტს, რომელიც ამ ლოქის გამო ჰქონდ და ისეტავ სხვას 			შესაბამისს.	
	bool cmp_priorities  და bool cmp_priorities_donor  ->  compare functions , ალაგებენ ორ სხვადასხვა ელემენტის ლისტს efficient_priority ს კლებადობის მიხედვით.

synch.h
	struct list lock_donations;   									ინახავს იმ ლოქებს, რომლებზეც დონეიშენი გაიცა.
	void donate_priority(struct thread * recipient, struct thread * donor, struct lock * lock);	შესაბამის ლოქზე, ერთი ნაკადი აძლებს პრიორიტეტს მეორეს. გამოიძახება
													lock_acquire() ში.
	void releasing(struct thread * current, struct lock * lock);					შესაბამის ლოქზე, current thread იცილებს იმ პრიორიტეტს, რომელიც ამ ლოქის 													გამო ჰქონდა

2.	Algorithms
	-- Choosing the next thread to run:
		scheduler ყოველ შემდეგ ნაკადს იღებს ready_list დან, ready_list არის დასორტირებული ლისტი პრიორიტეტების კლებადობის მიხედვით
		შესაბამისად next thread to run იქნება ის thread, რომელსაც იმ მომენტში ყველაზე მაღალი პრიორიტეტი აქვს.
		ლისტში ჩაინსერტება ხდება list_insert_ordered() მეთოდით, ლისტიდან ამოღება list_pop_front() მეთოდით
	-- Acquiring a Lock:
		lock_acquire() ში, თუ კი ნაკადი ცდილობს იმ ლოქის აღებას, რომელიც სხვა დაბალ პრიორიტეტიან ნაკადს აქვს, მანამ სანამ თვითონ დაიბლოკება,
		თავის პრიორიტეტს ანიჭებს ლოქის მფობელ ნაკადს. ლოქის მფლობელი thread  get_priority() მეთოდის საშუალებით, იღებს უფრო მაღალ პრიორიტეტს.
		ლოქი კი შეინახება lock_donations ლისტში, რომ გაირკვეს, რომელ ლოქზე იყო დონეიშენი გაცემული. (lock_release() მეთოდში)
		იმისათვის, რომ ready-list ში ხელახლა მოხდეს გადალაგება უკვე განახლებული პრიორიტეტის მიხედვით, donor thread ხელახლა ინსერტდება ready_list ში [O(n)], 
		რაც იწვევს იმას, რომ ready_list დასორტირდება სწორად. 
		დონაციის შემდეგ, მიმდინარე ნაკადი იბლოკება.
	-- Releasing a Lock:
		თუ კი release მოხდა ისეთ ლოქზე, რომელზეც ოდესმე donation იყო გაცემული, ნაკადი რომელსაც პრიორიტეტი ამ ლოქის გამო ჰქონდა მიღებული, ვალდებულია 		დაბრუნდეს საწყის  მდგომარეობაში (იგულისხმება თავისი პრიორიტეტი  დაიბრუნოს ან დაისეტოს სხვა, თუ სხვა ლოქისთვისაც ჰქონდა) და სხვა ნაკადებსაც რომლებსაც 			მისგან ჰქონდათ მიღებული  პრიორიტეტი, დაუსეტოს ახალი, ის რაც თვითონ აქვს.
		lock  ამოვარდება lock_donations ს ლისტიდან, რაც O(n) (იმის გავთვალისწინებით, რომ შესაბამისი ლოქი ჯერ უნდა მოიძებნოს ლისტში). 
	-- Computing the effective priority:
		ყოველ ნაკადს აქვს ორი ტიპის პრიორიტეტი  -  1. priority  რომელიც ინიციალიზაციის დროს გადმოეცა ან thread_set_priority() მეთოდის საშუალებით მიიღო 			შემდგომში. 2. effective_priority რომლის მიხედვითაც ხდება რედი ლისტიდან შემდგომი ნაკადის ამორჩვეა. თავდაპირველად effective_priority ს
		მნიშვნელობა იგივეა რაც priority, იმ შემთხვევაში თუ კი ნაკადმა მიიღო სხვა რომელიმე ნაკადისგან პრიორიტეტი ლოქისთვის, effective_priority შეიცვლება
		(ხდებასხვა მაქსიმალური პრიორიტეტის მქონე ნაკადის პრიორიტეტის დასეტვა საკუთარ თავზე)), ხოლო priority რჩება იგივე.
	-- Priority scheduling for semaphores and locks:
		თითოეულ სემაფორა ინსტანსს აქვს ლისტი sema->waiters, რომელიც ინახავს იმ thread ებს რომლებიც ამ სემაფორის მნიშვნელობის გაზრდას ელოდებიან , 
		რათა შეამცირონ და კრიტიკულ სექციაში შევიდნენ. თავდაპირველ ვარიანტში ლისტი იყო queue, რაც არღვევდა priority scheduling ის პრინციპებს. 
		შესაბამისად ლისტში ჩაინსერტება  შეიცვალა list_insert_ordered და დალაგება ხდება ისევ thread  effective_priority ს მიხედვით.
		sema_up ში კი unblock ხდება იმ ნაკადის, რომელსაც ყველაზე მაღალი პრიორიტეტი აქვს.
		lock არის დაფუძნებული სემაფორზე, შესაბამისად იგივე წესები მოქმედებს ლოქზეც.
	-- Priority scheduling for condition variables:
		condition variable ში  wait ხდება semaphore_elem სტრუქტურაში არსებულ სემაფორაზე, semaphore_elem ინახება list ში cond->waiters.
		cond_signal() ში sema_up ს გადაეცემა შესაბამისი სემაფორა, რომლის value ს ინკერემენტიც უნდა მოხდეს, რადგანაც sema_up იცავს priority scheduling ის პრინციპებს,
		აღვიძებს, იმ ნაკადს რომელსაც ყველაზე მაღალი პრიორიტეტი აქვს, საჭიროა, რომ იმ სემაფორის გადაცემა მოხდეს sema_up მეთოდისთვის, რომელსაც ყველაზე მაღალმა 			პრიორიტეტიანმა ნაკადამ გამოაცხადა wait. აქედან გამომდინარე, list cond->waiters ინახავს, semaphore_elem  ტიპის სტრუქტურებს და დალაგება ხდება პრიორიტეტების
		struct semaphore_elem ში დამატებული int priority-ს მიხედვით. თითოეულ სემაფორას აქვს ის პრიორიტეტი რომელიც ჰქონდა, იმ ნაკადს რომელიც ბოლო ცდილობდა ამ 		სემაფორის მნიშვნელობის შემცირებას.
		
		sema_signal ის დროს, ჯერ ლისტიდან ამოვიღებთ იმ სემაფორას, რომელზეც ყველაზე მაღალმაპრიორიტეტიანმა ნაკადმა მოითხოვა შემცირება და ეს semaphore გადაეცემა 		sema_up რომელიც ისევ პრიორიტეტის მიხედვით გააღვიძებს threadს.
	-- Changing thread’s priority: 
		თითიეულ ნაკადს, აქვს სია იმ ნაკადებისა რომლებმაც პრიორიტეტები მისცეს, რომელიმე ლოქის გამო. ცხადია, აქედან ყველაზე მაღალი პრიორიტეტის შესაბამისი იქნება 		ნაკადის მიმდინარე პრიორიტეტი -  efficient-priority. 
		როდესაც thread იღებს პრიორიტეტს დონორისგან, საჭიროა თუ კი თვითონაც იყო სხვა ნაკადების დონორი, იმ ნაკადების პრიორიტეტებიც შეიცვალოს, რაც ხდება 		recursive_priority ფუნქციაში. რაც უზრუნველყოფს იმას, რომ რეკურსიულად ყველა ნაკადს, შესაბამისი, ახალი პრიორიტეტი დაესეტოს.
		
		removing_priority() ფუნქციაში, როდესაც ნაკადმა შეასრულა სამუშაო და გაანთავისუფლა ლოქი, რომლის გამოც ახალი პრიორიტეტი ჰქონდა, თავისი დონორების 		ლისტიდან აირჩევს შემდეგ ყველაზე მაღალ პრიორიტეტს, ან თუ ასეთი არ გააჩნია, დაუბრუნდება საწყისს პრიორიტეტს.
	
	B3: How do you ensure that the highest priority thread waiting for
	>> a lock, semaphore, or condition variable wakes up first?
	თითოეული იყინებეს wait_listს რომელშიც thread ები პრიორიტეტის მიხედვით არიან დალაგებული, და გაღვიძების მომენტში ირჩევენ ყველაზე მაღალ პრიორიტეტიან ნაკადს.
	B4: Describe the sequence of events when a call to lock_acquire()
	>> causes a priority donation.  How is nested donation handled?
	"Low-priority main thread L acquires lock A.  Medium-priority thread M then acquires lock B then blocks on acquiring lock A (L ნაკადის პრიორიტეტი ხდება M ის პრიორიტეტი
	L ის დონეიშენების ლისტში ემატება M, Lock A ემატება lock_donations ლისტში, როგორც ლოქი რომელზე პრიორიტეტი გაიცა). High-priority thread H then blocks on acquiring 		lock B .  Thus, thread H donates its priority to M (M ის დონეიშენების ლისტში ემატება L, lock B კი ინსერტდება lock_donations ში.), which in turn donates it to thread L.
	რადგანაც M-ის პრიორიტეტი შეიცვალა, რეკურსიულად გადაყოლა მოხდება ყველა ნაკადზე და იმ ნაკადების პრიორიტეტი, რომლებისაც M ის პრიორიტეტი იყო შეიცვლება. 
	ამ შემთხვევაში L. 
	B5: Describe the sequence of events when lock_release() is called
	>> on a lock that a higher-priority thread is waiting for.
	წინა მაგალითის მიხედვით, როცა ნაკადი L გაანთავისუფლებს ლოქს M ამოვარდება L ის donation ლისტიდან და L ს დაუბრუნედება საწყისი პრიორიტეტი.
	შემდეგ გაეშვება ნაკადი M, რომელიც გაანთავისუფლებს ლოქს B , H როგორც დონორი ამოვარდება მისი ლისტიდან და შედეგად გაეშვება ბოლოს H.

	
	
3. 	Synchronization
		1. ready_list ში thread ის ჩაინსერტება, ხდება ყოველთვის  როდესაც interrupt ები გამორთულია. იმის გამო, რომ ready_list არის shared ყველა  ნაკადისთვის.
		სხვა ტიპის ლისტები, როგორიც არის donor_list არ საჭიროებს ასეთ დაცვას, რადგან თითოეულ ნაკადს აქვს თავისი საკუთარი და სხვა რომელიმე ნაკადი ვერ იქონიებს 			გავლენას მასზე.
		2. სტრუქტურა რომელზეც, thread racing შეიძლება მოხდეს არის lock_donations. როდესაც ნაკადი ათავასუფლებს ლოქს, მაშინ ხდება ამ ლოქის lock_donations ლისტიდან 		ამოღება, მაგრამ რადგანაც ერთი და იგივე ლოქი ორ ნაკადს ვერ ექნება, არ საჭიროებს დამატებით სინქრონიზაციის მექანიზმს.
		როდესაც ნაკადი, ცდილობს გაიგოს არსებობს თუ არა ასეთი ლოქი უკვე lock_donations ს ლისტში, (იმის გამო, რომ thread ლოქების მიხედვით იღებს დონეიშენებს და არ 		არის საჭირო ერთი და იგივე ლოქის გამო lock_donations ში ორი სვადასხვა ლისტი იყოს, რადგან თვითOნ მხოლოდ ერთხელ გაანთავისუფლებს ამ ლოქს და არა ორჯერ)
		საჭიროა ეს ძებნა მოხდეს, ისე , რომ სხვა ნაკადმა ვერ მოახერხოს იგივე ლოქის  ჩაინსერტება, რაც interrupt ების გამორთვით ხდება. ისევე როგორც
		list_insert_ordered find ფუნქციაც  O(n), შესაბამისად დრო რომელიც გამორთულ ინტერაფტებში იხარჯება საშუალოდ ნორმალურია.

		
	B6: Describe a potential race in thread_set_priority() and explain
	>> how your implementation avoids it.  Can you use a lock to avoid
	>> this race?
	
	thread_set_priority ში ის ნაწილი ინტერაფთები გამორთულია, რადგან შეიძლება 1. თვითოთ შეცვალოს თავისი პრიორიტეტი ამ მეთოდის გამოძახებით  და მეორე რომელიმე სხვა 	ნაკადმა გადასცეს პრიორიტეტი. იმისთვის რომ ეს ორი ერთად არ მოხდეს, საჭიროა სინქრონიზაციის მექანიზმი და ამ შემთხვევაში interrupt ების გამორთვა.

4.	RATIONALE
	 B7: Why did you choose this design?  In what ways is it superior to
	>> another design you considered?
	ავირჩიე იმიტომ, რომ ჩემი აზრით ძალიან counterintuitive გადაწყვეტილება იყო, მიუხედავად იმისა, რომ ვცდილობდი რაც შეიძლებოდა მარტივი ყოფილიყო ამოხსნის გზა, 		გასათვალისწინებელი იყო ისეთი დეტალებიც, რომლებიც ზოგადად ალგორითმის აღწერაში არ ჩანს.
		
	
======TASK 3 - ADVANCED SCHEDULER ====

---- DATA STRUCTURES ----

>> thread-ის სტრუქტურაში დავამატეთ int nice; ცვლადი, რომელიც თრედის niceness ინახავს.
>> ასევე დაემატა recent_cpu.
>> გლობალურად დავამატეთ load_avg ცვლადი;
>> გამოთვლები, პირობის თანახმად ხდება thread_tick()-ში.
---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer ticks | R(A) | R(B) | R(C) | P(A) | P(B) | P(C) | thread to run
------------|------|------|------|------|------|------|--------------
 0          |  0   |  0   |  0   |  63  |  61  |  59  |       A
 4          |  4   |  0   |  0   |  62  |  61  |  59  |       A
 8          |  8   |  0   |  0   |  61  |  61  |  59  |       B
12          |  8   |  4   |  0   |  61  |  60  |  59  |       A
16          |  12  |  4   |  0   |  60  |  60  |  59  |       B
20          |  12  |  8   |  0   |  60  |  59  |  59  |       A
24          |  16  |  8   |  0   |  59  |  59  |  59  |       C
28          |  16  |  8   |  4   |  59  |  59  |  58  |       B
32          |  16  |  12  |  4   |  59  |  58  |  58  |       A
36          |  20  |  12  |  4   |  58  |  58  |  58  |       C



